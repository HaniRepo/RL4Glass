# -*- coding: utf-8 -*-
"""analysis103.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MniIZ-NW2YYExdtVKhygtf4I5B6bA5ih
"""

from google.colab import drive
drive.mount('/content/drive')

import sys
sys.path.append('/content/drive/My Drive/Colab_Notebooks/RL')
import sys
import os

# Set the working directory
os.chdir('/content/drive/My Drive/Colab_Notebooks/RL')

# test
from simulator import GlassformSimulator

!pip install stable-baselines3[extra]
!pip install 'shimmy>=2.0'

import gym
from gym import spaces
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from simulator import GlassformSimulator

# Load reference data
reference_data = pd.read_csv("reference_table.csv")  # Adjust path

class ParisonControlEnvTgobDisturbance(gym.Env):
    def __init__(self, simulator):
        super(ParisonControlEnvTgobDisturbance, self).__init__()
        self.simulator = simulator
        self.reset()

        # Define action space (adjustments to t_settle, t_counter, t_cooling)
        self.action_space = spaces.Box(low=-1.0, high=1.0, shape=(3,), dtype=np.float32)

        # Define observation space including T_gob_init
        self.observation_space = spaces.Box(
            low=np.array([1100, 966, 374, 2.10 + 1.44, 4.08, 0]),
            high=np.array([1200, 1069, 387, 2.56 + 1.74, 4.82, 100]),
            dtype=np.float32
        )

    def reset(self):
        # Randomly select T_gob_init from the reference table
        selected_row = reference_data.sample(1).iloc[0]
        self.T_gob_init = selected_row["T_gob"]
        self.T_parison_nom = selected_row["T_parison_nom"]
        self.T_mold_nom = selected_row["T_mold_nom"]

        # Reset simulator
        self.simulator.reset(T_mold=self.T_mold_nom)
        self.simulator.T_gob = self.T_gob_init
        self.simulator.T_air = 50
        self.simulator.t_settle = 2.33
        self.simulator.t_counter = 1.59
        self.simulator.t_cooling = 4.45

        # Run initial stabilization cycles
        for _ in range(200):
            self.simulator.simulate_cycle()

        # Apply disturbance
        self.simulator.T_gob += 1
        self.simulator.simulate_cycle()

        self.integral_error = 0  # Reset error accumulation
        self.current_step = 0
        return self._get_observation()

    def step(self, action):
        # Apply RL actions
        self.simulator.t_settle = np.clip(2.33 + action[0] * 0.23, 2.10, 2.56)
        self.simulator.t_counter = np.clip(1.59 + action[1] * 0.15, 1.44, 1.74)
        self.simulator.t_cooling = np.clip(4.45 + action[2] * 0.37, 4.08, 4.82)

        self.simulator.simulate_cycle()
        error = abs(self.simulator.T_parison - self.T_parison_nom)
        self.integral_error = 0.99 * self.integral_error + error
        reward = - (error + 0.01 * self.integral_error)

        done = error < 0.5 or self.current_step >= 200
        self.current_step += 1
        return self._get_observation(), reward, done, {}

    def _get_observation(self):
        return np.array([
            self.simulator.T_gob,
            self.simulator.T_parison,
            self.simulator.T_mold,
            self.simulator.t_settle + self.simulator.t_counter,
            self.simulator.t_cooling,
            self.integral_error
        ], dtype=np.float32)

# Train RL Model
env = make_vec_env(lambda: ParisonControlEnvTgobDisturbance(GlassformSimulator()), n_envs=1)
model = PPO("MlpPolicy", env, ent_coef=0.01, verbose=1)
model.learn(total_timesteps=100000)
model.save("ppo_parison_control_with_tgob_variability")

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from stable_baselines3 import PPO
from simulator import GlassformSimulator

# Load RL Model
model = PPO.load("ppo_parison_control_with_tgob_variability")

# Initialize simulator
simulator = GlassformSimulator()
simulator.reset(T_mold=377.417389538296)  # tHIS VALUE SHOULD BE CHANGED BASED ON THE t_GOB_INIT YOU CHOOSE
simulator.T_gob = 1185  # Initial T_gob from ANY NUMBER FROM 1100 TO 1200
simulator.T_air = 50  # Fixed T_air
simulator.t_settle = 2.33
simulator.t_counter = 1.59
simulator.t_cooling = 4.45

# Detect steady state before applying RL
STEADY_WINDOW = 50
SLOPE_THRESHOLD = 0.01
parison_temps = []
time_steps = []
log_data = []
steady_cycle = None

for i in range(1000):
    simulator.simulate_cycle()
    parison_temps.append(simulator.T_parison)
    time_steps.append(i)

    if i >= STEADY_WINDOW:
        recent_temps = parison_temps[-STEADY_WINDOW:]
        slope = (recent_temps[-1] - recent_temps[0]) / STEADY_WINDOW
        if abs(slope) <= SLOPE_THRESHOLD:
            steady_cycle = i
            print(f"Steady state reached at cycle {steady_cycle}")
            break

if steady_cycle is None:
    print("Steady state not reached within the simulation time.")
    exit()

steady_gob_temp = simulator.T_parison
print(f"Steady Parison Temperature: {steady_gob_temp:.2f}°C")

# Apply disturbance
simulator.T_gob += 1  # Disturbance: Increase T_gob by 1°C
print("\nDisturbance applied: T_gob increased by 1°C.")

# Closed-loop RL control
time_steps = []
gob_temps = []
mold_temps = []
t_contact_values = []
t_cooling_values = []
error_history = []
integral_error = 0

obs = np.array([
    simulator.T_parison,
    simulator.T_mold,
    simulator.t_settle + simulator.t_counter,
    simulator.T_gob,
    simulator.t_cooling,
    integral_error
])

stable_cycles = 0
for i in range(steady_cycle + 1, steady_cycle + 350):
    action, _ = model.predict(obs, deterministic=True)

    simulator.t_settle = np.clip(2.33 + action[0] * 0.23, 2.10, 2.56)
    simulator.t_counter = np.clip(1.59 + action[1] * 0.15, 1.44, 1.74)
    simulator.t_cooling = np.clip(4.45 + action[2] * 0.37, 4.08, 4.82)

    simulator.simulate_cycle()
    gob_temp = simulator.T_parison
    mold_temp = simulator.T_mold
    error = abs(gob_temp - steady_gob_temp)
    integral_error += error

    time_steps.append(i)
    gob_temps.append(gob_temp)
    mold_temps.append(mold_temp)
    t_contact_values.append(simulator.t_settle + simulator.t_counter)
    t_cooling_values.append(simulator.t_cooling)
    error_history.append(error)

    log_data.append({

        "T_parison": gob_temp,
        "T_mold": mold_temp,
        "T_gob": simulator.T_gob,
        "t_contact": simulator.t_settle + simulator.t_counter,
        "t_cooling": simulator.t_cooling,
        "Error": error,
        #"Cycle": i

    })

    print(f"Cycle: T_parison = {gob_temp:.2f}, Error = {error:.2f}")

    if error < 0.5:
        stable_cycles += 1
    else:
        stable_cycles = 0  # Reset stable count if error increases

    if stable_cycles >= 5:
        print(f"✅ System fully stabilized!")
        break

    obs = np.array([
        gob_temp, simulator.T_mold, simulator.t_settle + simulator.t_counter,
        simulator.T_gob, simulator.t_cooling, integral_error
    ])

# Save log data to CSV
log_df = pd.DataFrame(log_data)
log_file = "parison_control_log.csv"
log_df.to_csv(log_file, index=False)
print(f"Log data saved to {log_file}")

# Automatically download the log file
from google.colab import files
files.download(log_file)

# Plot Parison Temperature
plt.figure(figsize=(12, 6))
plt.plot(time_steps, gob_temps, label="T_parison (Parison Temperature)", color="blue")
plt.axhline(y=steady_gob_temp, color="orange", linestyle="--", label="Target T_parison")
plt.xlabel("Simulation Cycles")
plt.ylabel("Parison Temperature (°C)")
plt.title("Parison Temperature During RL Recovery")
plt.legend()
plt.grid(True)
plt.show()

# Plot Error History
plt.figure(figsize=(12, 6))
plt.plot(time_steps, error_history, label="Error", color="red")
plt.xlabel("Simulation Cycles")
plt.ylabel("Error (°C)")
plt.title("Error Reduction During RL Recovery")
plt.legend()
plt.grid(True)
plt.show()