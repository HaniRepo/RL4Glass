# -*- coding: utf-8 -*-
"""analysis110.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s8bWNoqyy-0qH4yNDVWvt9R8fIj0gBOh
"""

from google.colab import drive
drive.mount('/content/drive')

import sys
sys.path.append('/content/drive/My Drive/delivery')
import sys
import os

# Set the working directory
os.chdir('/content/drive/My Drive/delivery')

# test
from simulator import GlassformSimulator

from simulator import GlassformSimulator
import matplotlib.pyplot as plt

if __name__ == '__main__':

    T_GOB                =    1150
    T_AIR                =      50
    CYCLE_TIME           =   13.36


    sim = GlassformSimulator()
    sim.t_cycle = CYCLE_TIME
    sim.T_air = T_AIR
    sim.t_settle = 106 / 360 * CYCLE_TIME * 0.6
    sim.t_counter = 106 / 360 * CYCLE_TIME * 0.4
    sim.t_cooling = 120 / 360 * CYCLE_TIME
    sim.t_cooling_start = 0.0
    sim.T_gob = T_GOB

    time = []
    parisons = []
    molds = []
    sim.reset(T_mold=381.05)
    for i, _ in enumerate(range(300)):

        sim.simulate_cycle()
        time.append(i)
        parisons.append(sim.T_parison)
        molds.append(sim.T_mold)


    print(f"mold={sim.T_mold:.1f}, parison={sim.T_parison:.1f}")

    plt.plot(time, parisons)

    #plt.plot(time, molds)
    plt.show()

!pip install stable-baselines3[extra]
!pip install 'shimmy>=2.0'

import gym
from gym import spaces
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from simulator import GlassformSimulator

# Load reference data
reference_data = pd.read_csv("reference_table.csv")  # Adjust path

class ParisonControlEnvTgobDisturbance(gym.Env):
    def __init__(self, simulator):
        super(ParisonControlEnvTgobDisturbance, self).__init__()
        self.simulator = simulator

        # Define action space (adjustments to t_settle, t_counter, t_cooling)
        self.action_space = spaces.Box(low=-1.0, high=1.0, shape=(3,), dtype=np.float32)

        # Define observation space including T_gob_init
        self.observation_space = spaces.Box(
            low=np.array([1100, 966, 374, 2.10 + 1.44, 4.08, 0, 0]) / 10000,  # Normalize by 10000
            high=np.array([1200, 1069, 387, 2.56 + 1.74, 4.82, 100, 3]) / 10000,  # Normalize by 10000
            dtype=np.float32
        )

        self.reset()

    def reset(self):
        # Randomly select T_gob_init from the reference table
        selected_row = reference_data.sample(1).iloc[0]
        self.T_gob_init = selected_row["T_gob"]
        self.T_parison_nom = selected_row["T_parison_nom"]
        self.T_mold_nom = selected_row["T_mold_nom"]

        # Reset simulator
        self.simulator.reset(T_mold=self.T_mold_nom)
        self.simulator.T_gob = self.T_gob_init
        self.simulator.T_air = 50
        self.simulator.t_settle = 2.33
        self.simulator.t_counter = 1.59
        self.simulator.t_cooling = 4.45

        # Run initial stabilization cycles
        for _ in range(200):
            self.simulator.simulate_cycle()

        # **Apply randomized disturbance** (between +1°C and +3°C)
        self.disturbance = np.random.uniform(1, 3)
        self.simulator.T_gob += self.disturbance
        self.simulator.simulate_cycle()

        self.integral_error = 0  # Reset error accumulation
        self.current_step = 0
        return self._get_observation()

    def step(self, action):
        # Apply RL actions
        self.simulator.t_settle = np.clip(2.33 + action[0] * 0.23, 2.10, 2.56)
        self.simulator.t_counter = np.clip(1.59 + action[1] * 0.15, 1.44, 1.74)
        self.simulator.t_cooling = np.clip(4.45 + action[2] * 0.37, 4.08, 4.82)

        self.simulator.simulate_cycle()
        error = abs(self.simulator.T_parison - self.T_parison_nom)
        self.integral_error = 0.99 * self.integral_error + error

        # **Log-scaled reward to prevent extreme values**
        reward = - np.log1p(error + 0.01 * self.integral_error)

        done = error < 0.5 or self.current_step >= 350  # More time for large recovery
        self.current_step += 1
        return self._get_observation(), reward, done, {}

    def _get_observation(self):
        obs = np.array([
            self.simulator.T_gob,
            self.simulator.T_parison,
            self.simulator.T_mold,
            self.simulator.t_settle + self.simulator.t_counter,
            self.simulator.t_cooling,
            self.integral_error,
            self.disturbance  # Add disturbance value
        ], dtype=np.float32)

        # **More precise normalization**
        obs = (obs - np.mean(obs)) / (np.std(obs) + 1e-8)  # Prevent division by zero
        return obs

# ✅ **Train RL Model with new settings**
env = make_vec_env(lambda: ParisonControlEnvTgobDisturbance(GlassformSimulator()), n_envs=1)

model = PPO(
    "MlpPolicy",
    env,
    learning_rate=0.0005,  # Increase learning rate for faster updates
    vf_coef=1.0,  # Give more importance to the critic
    gamma=0.97,  # Let the agent consider longer-term rewards
    n_steps=8192,
    batch_size=256,
    clip_range=0.2,
    ent_coef=0.005,
    verbose=1
)

model.learn(total_timesteps=200000)  # Train for 200K steps
model.save("ppo_parison_control_with_variable_disturbances")

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from stable_baselines3 import PPO
from simulator import GlassformSimulator

# Load RL Model
model = PPO.load("ppo_parison_control_with_variable_disturbances")

# Initialize simulator
simulator = GlassformSimulator()
simulator.reset(T_mold=377.417389538296)  # Change this based on T_gob_init
simulator.T_gob = 1125  # Initial T_gob (Choose from 1100 to 1200)
simulator.T_air = 50
simulator.t_settle = 2.33
simulator.t_counter = 1.59
simulator.t_cooling = 4.45
simulator.t_cycle = 13.36

# Detect steady state before applying RL
STEADY_WINDOW = 50
SLOPE_THRESHOLD = 0.01
parison_temps = []
time_steps = []
log_data = []
steady_cycle = None

for i in range(1000):
    simulator.simulate_cycle()
    parison_temps.append(simulator.T_parison)
    time_steps.append(i)

    if i >= STEADY_WINDOW:
        recent_temps = parison_temps[-STEADY_WINDOW:]
        slope = (recent_temps[-1] - recent_temps[0]) / STEADY_WINDOW
        if abs(slope) <= SLOPE_THRESHOLD:
            steady_cycle = i
            print(f"Steady state reached at cycle {steady_cycle}")
            break

if steady_cycle is None:
    print("Steady state not reached within the simulation time.")
    exit()

steady_gob_temp = simulator.T_parison
print(f"Steady Parison Temperature: {steady_gob_temp:.2f}°C")

# Apply disturbance
disturbance = 2  # Disturbance: Increase T_gob by 2°C
simulator.T_gob += disturbance
print("\nDisturbance applied: T_gob increased by 2°C.")

# Closed-loop RL control
time_steps = []
gob_temps = []
mold_temps = []
t_contact_values = []
t_cooling_values = []
error_history = []
integral_error = 0

# Initial observation with correct 7D shape
obs = np.array([
    simulator.T_gob, simulator.T_parison, simulator.T_mold,
    simulator.t_settle + simulator.t_counter, simulator.t_cooling,
    integral_error, disturbance  # ✅ Include disturbance
])

stable_cycles = 0
for i in range(steady_cycle + 1, steady_cycle + 350):
    action, _ = model.predict(obs, deterministic=True)

    simulator.t_settle = np.clip(2.33 + action[0] * 0.23, 2.10, 2.56)
    simulator.t_counter = np.clip(1.59 + action[1] * 0.15, 1.44, 1.74)
    simulator.t_cooling = np.clip(4.45 + action[2] * 0.37, 4.08, 4.82)

    simulator.simulate_cycle()
    gob_temp = simulator.T_parison
    mold_temp = simulator.T_mold
    error = abs(gob_temp - steady_gob_temp)
    integral_error += error

    time_steps.append(i)
    gob_temps.append(gob_temp)
    mold_temps.append(mold_temp)
    t_contact_values.append(simulator.t_settle + simulator.t_counter)
    t_cooling_values.append(simulator.t_cooling)
    error_history.append(error)

    log_data.append({
        "T_parison": gob_temp,
        "T_mold": mold_temp,
        "T_gob": simulator.T_gob,
        "t_contact": simulator.t_settle + simulator.t_counter,
        "t_cooling": simulator.t_cooling,
        "Error": error,
    })

    print(f"Cycle: T_parison = {gob_temp:.2f}, Error = {error:.2f}")

    if error < 0.5:
        stable_cycles += 1
    else:
        stable_cycles = 0  # Reset stable count if error increases

    if stable_cycles >= 5:
        print(f"✅ System fully stabilized!")
        break

    # ✅ Ensure 7D observation shape is maintained in each step
    obs = np.array([
        simulator.T_gob, gob_temp, simulator.T_mold,
        simulator.t_settle + simulator.t_counter, simulator.t_cooling,
        integral_error, disturbance  # ✅ Keep disturbance
    ])

# Save log data to CSV
log_df = pd.DataFrame(log_data)
log_file = "parison_control_log.csv"
log_df.to_csv(log_file, index=False)
print(f"Log data saved to {log_file}")

# Automatically download the log file
from google.colab import files
files.download(log_file)

# Plot Parison Temperature
plt.figure(figsize=(12, 6))
plt.plot(time_steps, gob_temps, label="T_parison (Parison Temperature)", color="blue")
plt.axhline(y=steady_gob_temp, color="orange", linestyle="--", label="Target T_parison")
plt.xlabel("Simulation Cycles")
plt.ylabel("Parison Temperature (°C)")
plt.title("Parison Temperature During RL Recovery")
plt.legend()
plt.grid(True)
plt.show()

# Plot Error History
plt.figure(figsize=(12, 6))
plt.plot(time_steps, error_history, label="Error", color="red")
plt.xlabel("Simulation Cycles")
plt.ylabel("Error (°C)")
plt.title("Error Reduction During RL Recovery")
plt.legend()
plt.grid(True)
plt.show()